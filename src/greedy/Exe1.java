package greedy;

import data_structure.AcyclicGraph;
import data_structure.UndirectedAcyclicAcyclicGraph;

/**
 * Exe1 is for exercise1.
 * <p>
 * The question is as follows:<br>
 * 实现Huffman算法、最大生成树、单源最短路径(SSSP)的Dijkstra算法。（Java or Python）
 *
 * @author Frank_Xiao
 */
public class Exe1 {
    /**
     * Huffman algorithm implementation
     *
     * @param percents an array to store the percentage of each element
     */
    public static void Huffman(int[] percents) {

    }

    /**
     * Kruskal algorithm implementation
     *
     * @param graph the graph to be calculated
     */
    public static void Kruskal(UndirectedAcyclicAcyclicGraph graph) {
        int small = Integer.MAX_VALUE;
        int start, end;
        System.out.println(graph.getTotalNodes());
    }

    /**
     * Dijkstra algorithm implementation
     *
     * @param graph the graph to be calculated
     */
    public static void Dijkstra(AcyclicGraph graph) {

    }
}
